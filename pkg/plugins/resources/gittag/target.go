package gittag

import (
	"fmt"

	"github.com/sirupsen/logrus"
	"github.com/updatecli/updatecli/pkg/core/result"
)

// Target creates a tag if needed from a local git repository, without pushing the tag
func (gt *GitTag) Target(source string, dryRun bool) (bool, error) {
	// Ensure that a git message is present to annotate the tag to create
	if len(gt.spec.Message) == 0 {
		// absence of a message is not blocking: warn the user and continue
		gt.spec.Message = "Generated by updatecli"
		logrus.Warningf("No specified message for gittag target. Using default value %q", gt.spec.Message)
	}

	// Fail if a pattern is specified
	if gt.versionFilter.Pattern != "" {
		return false, fmt.Errorf("target validation error: spec.versionfilter.pattern is not allowed for targets of type gittag")
	}

	// Fail if the git tag resource cannot be validated
	err := gt.Validate()
	if err != nil {
		logrus.Errorln(err)
		return false, err
	}

	// Check if the provided tag (from source input value) already exists
	gt.versionFilter.Pattern = source
	tags, err := gt.nativeGitHandler.Tags(gt.spec.Path)
	if err != nil {
		return false, err
	}
	gt.foundVersion, err = gt.versionFilter.Search(tags)
	if err != nil && err.Error() != fmt.Sprintf("No version found matching pattern %q", source) {
		// Something went wrong during the tag search.
		return false, err
	}
	if gt.foundVersion.GetVersion() == source {
		// No error, but no change
		logrus.Printf("%s The Git Tag %q already exists, nothing else to do.",
			result.SUCCESS,
			source)
		return false, nil
	}

	// Otherwise proceed to create this new tag
	logrus.Printf("%s The git tag %q does not exist: creating it.", result.ATTENTION, source)

	if dryRun {
		// Dry run: no changes to apply.
		// Return early without creating tag but notify that a change should be made.
		return true, nil
	}

	changed, err := gt.nativeGitHandler.NewTag(source, gt.spec.Message, gt.spec.Path)
	if err != nil {
		return changed, err
	}
	logrus.Printf("%s The git tag %q has been created.", result.ATTENTION, source)

	return changed, nil
}
